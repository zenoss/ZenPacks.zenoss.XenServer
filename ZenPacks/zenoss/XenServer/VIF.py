######################################################################
#
# Copyright (C) Zenoss, Inc. 2013, all rights reserved.
#
# This content is made available according to terms specified in
# License.zenoss under the directory where your Zenoss product is
# installed.
#
######################################################################

import logging
LOG = logging.getLogger('xen.XenServer')

from zope.component import adapts
from zope.interface import implements

from Products.ZenRelations.RelSchema import ToMany, ToManyCont, ToOne
from Products.ZenUtils.Utils import prepId
from Products.Zuul.catalog.paths import DefaultPathReporter, relPath
from Products.Zuul.form import schema
from Products.Zuul.infos import ProxyProperty
from Products.Zuul.utils import ZuulMessageFactory as _t

from ZenPacks.zenoss.XenServer import CLASS_NAME, MODULE_NAME
from ZenPacks.zenoss.XenServer.utils import (
    PooledComponent, IPooledComponentInfo, PooledComponentInfo,
    RelationshipInfoProperty,
    updateToOne,
    id_from_ref,
    )


class VIF(PooledComponent):
    '''
    Model class for VIF (virtual interface.)
    '''

    class_label = 'Virtual NIC'
    class_plural_label = 'Virtual NICs'

    meta_type = portal_type = 'XenServerVIF'

    xenapi_metrics_ref = None
    macaddress = None
    mac_autogenerated = None
    mtu = None
    allowed_operations = None
    currently_attached = None
    vif_device = None
    ipv4_allowed = None
    ipv6_allowed = None
    locking_mode = None

    _properties = PooledComponent._properties + (
        {'id': 'xenapi_metrics_ref', 'label': 'XENAPI Metrics Reference', 'type': 'string', 'mode': 'w'},
        {'id': 'macaddress', 'label': 'MAC Address', 'type': 'string', 'mode': 'w'},
        {'id': 'mac_autogenerated', 'label': 'Autogenerate MAC Address', 'type': 'boolean', 'mode': 'w'},
        {'id': 'mtu', 'label': 'MTU', 'type': 'string', 'mode': 'w'},
        {'id': 'allowed_operations', 'label': 'Allowed Operations', 'type': 'lines', 'mode': 'w'},
        {'id': 'currently_attached', 'label': 'Currently Attached', 'type': 'boolean', 'mode': 'w'},
        {'id': 'vif_device', 'label': 'Device Name', 'type': 'string', 'mode': 'w'},
        {'id': 'ipv4_allowed', 'label': 'IPv4 Allowed', 'type': 'lines', 'mode': 'w'},
        {'id': 'ipv6_allowed', 'label': 'IPv6 Allowed', 'type': 'lines', 'mode': 'w'},
        {'id': 'locking_mode', 'label': 'Locking Mode', 'type': 'string', 'mode': 'w'},
        )

    _relations = PooledComponent._relations + (
        ('vm', ToOne(ToManyCont, MODULE_NAME['VM'], 'vifs')),
        ('network', ToOne(ToMany, MODULE_NAME['Network'], 'vifs')),
        )

    _catalogs = dict({
        'VIFCatalog': {
            'deviceclass': '/XenServer',
            'indexes': {
                'ipv4_addresses': {'type': 'keyword'},
                'mac_addresses': {'type': 'keyword'},
                },
            },
        }, **PooledComponent._catalogs)

    @property
    def ipv4_addresses(self):
        return self.ipv4_allowed

    @property
    def mac_addresses(self):
        return (self.macaddress,)

    @classmethod
    def objectmap(cls, ref, properties):
        '''
        Return an ObjectMap given XenAPI VIF ref and properties.
        '''
        if 'uuid' not in properties:
            return {
                'compname': 'vms/{}'.format(id_from_ref(properties['parent'])),
                'relname': 'vifs',
                'id': id_from_ref(ref),
                }

        title = properties.get('device') or properties['uuid']

        return {
            'compname': 'vms/{}'.format(id_from_ref(properties.get('VM'))),
            'relname': 'vifs',
            'id': id_from_ref(ref),
            'title': title,
            'xenapi_ref': ref,
            'xenapi_metrics_ref': properties.get('metrics'),
            'xenapi_uuid': properties.get('uuid'),
            'macaddress': properties.get('MAC'),
            'mac_autogenerated': properties.get('MAC_autogenerated'),
            'mtu': properties.get('MTU'),
            'allowed_operations': properties.get('allowed_operations'),
            'currently_attached': properties.get('currently_attached'),
            'vif_device': properties.get('device'),
            'ipv4_allowed': properties.get('ipv4_allowed'),
            'ipv6_allowed': properties.get('ipv6_allowed'),
            'locking_mode': properties.get('locking_mode'),
            'setNetwork': id_from_ref(properties.get('network')),
            }

    @classmethod
    def findByIP(cls, dmd, ipv4_addresses):
        '''
        Return the first VIF matching one of ipv4_addresses.
        '''
        return next(cls.search(
            dmd, 'VIFCatalog', ipv4_addresses=ipv4_addresses), None)

    @classmethod
    def findByMAC(cls, dmd, mac_addresses):
        '''
        Return the first VIF matching one of mac_addresses.
        '''
        return next(cls.search(
            dmd, 'VIFCatalog', mac_addresses=mac_addresses), None)

    def getNetwork(self):
        '''
        Return network id or None.

        Used by modeling.
        '''
        obj = self.network()
        if obj:
            return obj.id

    def setNetwork(self, network_id):
        '''
        Set network by id.

        Used by modeling.
        '''
        updateToOne(
            relationship=self.network,
            root=self.device(),
            type_=CLASS_NAME['Network'],
            id_=network_id)

    def xenrrd_prefix(self):
        '''
        Return prefix under which XenServer stores RRD data about this
        component.
        '''
        vm_uuid = self.vm().xenapi_uuid
        if vm_uuid and self.vif_device:
            return ('vm', vm_uuid, '_'.join(('vif', self.vif_device)))

    def getIconPath(self):
        '''
        Return URL to icon representing objects of this class.
        '''
        return '/++resource++xenserver/img/virtual-network-interface.png'

    def guest_interface(self):
        '''
        Return the guest interface associated with this VIF.
        '''
        if not self.vif_device:
            return

        guest_device = self.vm().guest_device()
        if guest_device:
            return guest_device.os.interfaces._getOb(
                prepId(self.vif_device), None)


class IVIFInfo(IPooledComponentInfo):
    '''
    API Info interface for VIF.
    '''

    vm = schema.Entity(title=_t(u'VM'))
    network = schema.Entity(title=_t(u'Network'))
    guest_interface = schema.Entity(title=_t(u'Guest Interface'))

    macaddress = schema.TextLine(title=_t(u'MAC Address'))
    mac_autogenerated = schema.TextLine(title=_t(u'Autogenerate MAC Address'))
    mtu = schema.TextLine(title=_t(u'MTU'))
    allowed_operations = schema.TextLine(title=_t(u'Allowed Operations'))
    currently_attached = schema.TextLine(title=_t(u'Currently Attached'))
    vif_device = schema.TextLine(title=_t(u'Device Name'))
    ipv4_allowed = schema.TextLine(title=_t(u'IPv4 Allowed'))
    ipv6_allowed = schema.TextLine(title=_t(u'IPv6 Allowed'))
    locking_mode = schema.TextLine(title=_t(u'Locking Mode'))


class VIFInfo(PooledComponentInfo):
    '''
    API Info adapter factory for VIF.
    '''

    implements(IVIFInfo)
    adapts(VIF)

    vm = RelationshipInfoProperty('vm')
    network = RelationshipInfoProperty('network')
    guest_interface = RelationshipInfoProperty('guest_interface')

    xenapi_metrics_ref = ProxyProperty('xenapi_metrics_ref')
    macaddress = ProxyProperty('macaddress')
    mac_autogenerated = ProxyProperty('mac_autogenerated')
    mtu = ProxyProperty('mtu')
    allowed_operations = ProxyProperty('allowed_operations')
    currently_attached = ProxyProperty('currently_attached')
    vif_device = ProxyProperty('vif_device')
    ipv4_allowed = ProxyProperty('ipv4_allowed')
    ipv6_allowed = ProxyProperty('ipv6_allowed')
    locking_mode = ProxyProperty('locking_mode')


class VIFPathReporter(DefaultPathReporter):
    '''
    Path reporter for VIF.
    '''

    def getPaths(self):
        paths = super(VIFPathReporter, self).getPaths()

        network = self.context.network()
        if network:
            paths.extend(relPath(network, 'endpoint'))

        vapp = self.context.vm().vmappliance()
        if vapp:
            paths.extend(relPath(vapp, 'endpoint'))

        return paths
